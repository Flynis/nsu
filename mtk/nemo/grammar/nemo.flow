import string;
import ds/tree;
import util/util;

export {   

    Int : ();
    Bool : ();
    NoType : ();
    AnyType : ();
    Array : (baseType: ExprType);
    VarType ::= Int, Bool, Array;
    ExprType ::= VarType, NoType, AnyType;


    VarDecl : (name: string, type: VarType);
    VarDeclList : (decls: [VarDecl]);
    varDeclList2s(vdl: VarDeclList) -> string;


    Var : (name : string);


    IntConst : (value: int);
    BoolConst : (value: bool);
    ArrayConst : (values: Tree<int, Const>);
    NonBoolConst ::= IntConst, ArrayConst;
    Const ::= NonBoolConst, BoolConst;
    const2s(c: Const) -> string;


    ArithmAddOp : ();
    ArithmSubOp : ();
    ArithmMulOp : ();
    ArithmDivOp : ();
    ArithmBinaryOp ::= ArithmAddOp, ArithmSubOp, ArithmMulOp, ArithmDivOp;


    ArithmNegOp : ();
    ArithmOp ::= ArithmBinaryOp, ArithmNegOp;


    ArithmBinary : (l: Expr, r: Expr, op: ArithmBinaryOp);
    ArithmNeg : (e: Expr);
    ArithmExpr ::= ArithmBinary, ArithmNeg;


    Equal : ();
    Less : ();
    ComparisonType ::= Equal, Less;
    Comparison : (l: Expr, r: Expr, comparisonType: ComparisonType);


    Not : (e: BooleanExpr);
    Or : (l: BooleanExpr, r: BooleanExpr);
    BooleanExpr ::= Comparison, Not, Or, BoolConst;
    

    ArrayUpdateOp : (i: Expr, v: Expr);
    ArrayApplyOp : (i: Expr);
    ArrayConcatOp : (arr2: Expr);
    ArrayLengthOp : ();
    ArrayOpType ::= ArrayUpdateOp, ArrayApplyOp, ArrayConcatOp, ArrayLengthOp;
    ArrayOp : (arr: Expr, opType: ArrayOpType);


    Expr ::= Var, Const, ArithmExpr, ArrayOp, BooleanExpr;
    expr2s(e: Expr) -> string;


    Assignment : (varName: string, expr: Expr);
    BodiesSeq : (bodies: [Body]);
    Test : (b: BooleanExpr);
    Print : (e: Expr);
    NonDeterChoice : (bodies: [Body]);
    NonDeterIteration : (body: Body);
    Body ::= Assignment, BodiesSeq, Test, NonDeterChoice, NonDeterIteration;
    body2s(b: Body) -> string;


    Program : (varDeclList: VarDeclList, body: Body);
    program2s(p: Program) -> string;

}


constTree2s(t: Tree<int, Const>) -> string {
    switch (popmax(t)) {
        EmptyPopResult(): "[]";        
        PopResult(key, val, rest): {
            maxIndex = key;
            vals = foldi(
                range(maxIndex + 1),
                "",
                \i, acc, c -> {
                    curConst = lookupTree(t, c);
                    s = eitherMap(curConst, const2s, "_");
                    tmp = acc + s;
                    if (i == maxIndex) tmp else tmp + ", ";
                }
            );
            "[" + vals + "]";
        }
    };
}


exprType2s(t: ExprType) -> string {
    switch (t) {
        Int(): "INT";
        Bool(): "BOOL";
        Array(baseType): "[" + exprType2s(baseType) + "]";
        NoType(): "<No type>";
        AnyType(): "<Any type>";
    }
}


varDecl2s(vd: VarDecl) -> string {
    "VAR " + vd.name + " : " + exprType2s(vd.type) + ";";
}


varDeclList2s(vdl: VarDeclList) -> string {
    fold(vdl.decls, "", \s, d -> {
        s + varDecl2s(d) + "\n";
    })
}


boolConst2s(b: BoolConst) -> string {
    b2s(b.value);
}


const2s(c: Const) -> string {
    switch (c) {
        IntConst(value): i2s(value);
        BoolConst(value): boolConst2s(c);
        ArrayConst(values): constTree2s(values);
    }
}


arithmExpr2s(aexpr: ArithmExpr) -> string {
    withoutParentheses = switch (aexpr) {
        ArithmBinary(l, r, op): {
            ls = expr2s(l);
            rs = expr2s(r);
            switch (op) {
                ArithmAddOp(): ls + " + " + rs;
                ArithmSubOp(): ls + " - " + rs;
                ArithmMulOp(): ls + " * " + rs;
                ArithmDivOp(): ls + " / " + rs;
            }
        }
        ArithmNeg(e): "-" + expr2s(e);
    }

    "(" + withoutParentheses + ")";
}


arrayOp2s(arrayOp: ArrayOp) -> string {
    fst = expr2s(arrayOp.arr);

    switch (arrayOp.opType) {
        ArrayUpdateOpType(ind, val): "UPD(" + fst + ", " + expr2s(ind) + ", " + expr2s(val) + ")";

        ArrayApplyOpType(ind): "APP(" + fst + ", " + expr2s(ind) + ")";

        ArrayConcatOpType(arr2): "CONCAT(" + fst + ", " + expr2s(arr2) + ")";

        ArrayLengthOpType(): "LENGTH(" + fst + ")";
    }
}


comparisonType2s(ct: ComparisonType) -> string {
    switch (ct) {
        Equal(): " = ";
        Less(): " < ";
    }
}


booleanExpr2s(bexpr: BooleanExpr) -> string {
    switch (bexpr) {
        Comparison(l, r, ct): expr2s(l) + comparisonType2s(ct) + expr2s(r);
        Not(e): "NOT(" + booleanExpr2s(e) + ")";
        Or(l, r): "(" + booleanExpr2s(l) + ") OR (" + booleanExpr2s(r) + ")";
        BoolConst(value): boolConst2s(bexpr);
    }
}


expr2s(e: Expr) -> string {
    switch (e) {
        Var(name): name;
        NonBoolConst(): const2s(e);
        ArithmExpr(): arithmExpr2s(e);
        ArrayOp(arr, opType): arrayOp2s(e);
        BooleanExpr(): booleanExpr2s(e);
    }
}


bodiesSeq2s(bodies: [Body]) -> string {
    s = fold(bodies, "", \s, b -> {
        s + body2s(b);
    })
    "{\n" + s + "}\n";
}


nonDeterChoice2s(bodies: [Body]) -> string {
    foldi(
        bodies, 
        "",
        \i, acc, b -> {
            tmp = acc + body2s(b);
            if (i == length(bodies) - 1) tmp else tmp + "U\n";
        }
    );
}


body2s(b: Body) -> string {
    switch (body) {
        Assignment(varName, expr): varName + " := " + expr2s(expr) + ";\n";

        BodiesSeq(bodies): bodiesSeq2s(bodies);

        Test(b): "(" + booleanExpr2s(b) + ")?;\n";

        Print(expr): "PRINT(" + expr2s(expr) + ");\n";

        NonDeterChoice(bodies): nonDeterChoice2s(bodies);

        NonDeterIteration(b): "{\n" + body2s(b) + "}*\n";
    }
}


program2s(p: Program) -> string {
    varDeclList2s(p.varDeclList) + body2s(p.body);
}

